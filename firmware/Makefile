# SPDX-License-Identifier: GPL-2.0
#
# kbuild file for firmware/
#

CONFIG_EXTRA_FIRMWARE_DIR="firmware"

# Create $(fwabs) from $(CONFIG_EXTRA_FIRMWARE_DIR) -- if it doesn't have a
# leading /, it's relative to $(srctree).
fwdir := $(subst $(quote),,$(CONFIG_EXTRA_FIRMWARE_DIR))
fwabs := $(addprefix $(srctree)/,$(filter-out /%,$(fwdir)))$(filter /%,$(fwdir))

fw-external-y := $(subst $(quote),,$(CONFIG_EXTRA_FIRMWARE))

fw-external-$(CONFIG_TOUCHSCREEN_SEC_TS_Y79A) += tsp_sec/y771_y2_ub.bin tsp_sec/y79a_y2.bin tsp_sec/y79a_x1.bin \
							tsp_sec/y79a_y2_ub.bin tsp_sec/y79a_x1_ub.bin tsp_sec/y79a_z3.bin

fw-external-$(CONFIG_KEYBOARD_STM_FSR) += key_stm/fsr1ad04_p2.fw

ifdef CONFIG_SEC_C2Q_PROJECT
fw-external-$(CONFIG_TOUCHSCREEN_SEC_TS_Y79A_C) += tsp_sec/y79a_c2_y2ub.bin tsp_sec/y79a_c2_6layer.bin \
							tsp_sec/y79a_c2_4layer.bin
fw-external-$(CONFIG_EPEN_WACOM_W9020) += epen/w9020_c2.bin epen/w9020_c2_dv1.bin epen/w9020_c2_dv2.bin
endif
ifdef CONFIG_SEC_C1Q_PROJECT
fw-external-$(CONFIG_TOUCHSCREEN_SEC_TS_Y79A_C) += tsp_sec/y79a_c1_x1ub.bin tsp_sec/y79a_c1_old.bin tsp_sec/y771_c1_pv1.bin tsp_sec/y771_c1.bin
fw-external-$(CONFIG_EPEN_WACOM_W9020) += epen/w9020_c1_x1ub.bin epen/w9020_c1_y79a.bin epen/w9020_c1.bin
endif

fw-external-$(CONFIG_TOUCHSCREEN_FTS1BA90A) += tsp_stm/fts1ba90a_gts5.bin tsp_stm/fts1ba90a_gts7xl.bin
fw-external-$(CONFIG_TOUCHSCREEN_NOVATEK_NT36523) += tsp_novatek/nt36523_gts7l.bin

fw-external-$(CONFIG_TOUCHSCREEN_FTS9CU80F_B)	+= tsp_stm/fts9cu80f_bloom.fw tsp_stm/fts9cu80f_f2.fw
fw-external-$(CONFIG_TOUCHSCREEN_ZINITIX_ZTW522)	+= tsp_zinitix/ztw522_bloom.bin

ifdef CONFIG_SEC_GTS7L_PROJECT
fw-external-$(CONFIG_EPEN_WACOM_W9021) += epen/w9021_gts7l.bin epen/w9021_gts7l_pv1.bin epen/w9021_gts7l_pv2.bin
endif
ifdef CONFIG_SEC_GTS7XL_PROJECT
fw-external-$(CONFIG_EPEN_WACOM_W9021) += epen/w9021_gts7_bringup.bin epen/w9021_gts7xl.bin
endif

fw-external-$(CONFIG_TOUCHSCREEN_SEC_TS_Y771_SUB) += tsp_sec/y771_f2.bin
fw-external-$(CONFIG_KEYBOARD_STM32_POGO)	+= keyboard_stm/stm32_gts7l.bin

fw-external-$(CONFIG_WIRELESS_FIRMWARE_UPDATE) += mfc/mfc_fw_flash.bin
ifdef CONFIG_WIRELESS_CHARGER_MFC_S2MIW04
fw-external-$(CONFIG_WIRELESS_FIRMWARE_UPDATE) += mfc/mfc_fw_flash_s2miw04.bin
endif

ifdef CONFIG_SEC_GTS7XL_PROJECT
ifdef CONFIG_MACH_GTS7XL_USA_SINGLE
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t356_gts7xl_usa_main1.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_WIFI) += abov/a96t356_gts7xl_usa_wifi1.bin
else
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t356_gts7xl_main1.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_SUB) += abov/a96t356_gts7xl_main3wifi2.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_WIFI) += abov/a96t356_gts7xl_wifi1.bin
endif
else ifdef CONFIG_SEC_GTS7L_PROJECT
ifdef CONFIG_MACH_GTS7L_USA_SINGLE
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t356_gts7l_usa_main1.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_WIFI) += abov/a96t356_gts7l_usa_wifi1.bin
else ifdef CONFIG_MACH_GTS7LWIFI_EUR_OPEN
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t356_gts7lwifi_main1.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_WIFI) += abov/a96t356_gts7lwifi_wifi1.bin
else
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t356_gts7l_main1.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_WIFI) += abov/a96t356_gts7l_wifi1.bin
endif
endif

ifdef CONFIG_SEC_BLOOMXQ_PROJECT
fw-external-$(CONFIG_SENSORS_A96T3X6) += abov/a96t365_bloomxq_eur.bin
fw-external-$(CONFIG_SENSORS_A96T3X6_SUB) += abov/a96t365_bloomxq_sub_eur.bin
endif

fw-external-$(CONFIG_TOUCHSCREEN_MELFAS_MSS100) += tsp_melfas/mss100_r8.bin
fw-external-$(CONFIG_TOUCHSCREEN_ZINITIX_ZT7650) += tsp_zinitix/zt7650_r8.bin tsp_zinitix/zt7650m_r8.bin
fw-external-$(CONFIG_TOUCHSCREEN_STM_FTS5CU56A) += tsp_stm/fts5cu56a_r8.bin

ifdef CONFIG_SEC_C2Q_PROJECT
fw-external-$(CONFIG_SENSORS_VL53L5) += range_sensor/vl53l5_c2.bin \
					range_sensor/generic_xtalk_shape_c2_00.bin \
					range_sensor/generic_xtalk_shape_c2_01.bin \
					range_sensor/generic_xtalk_shape_c2_02.bin
endif

# FIVE
ifeq ($(CONFIG_FIVE_TEE_DRIVER),y)
include $(srctree)/firmware/five/Makefile
endif

quiet_cmd_ihex  = IHEX    $@
      cmd_ihex  = $(OBJCOPY) -Iihex -Obinary $< $@

quiet_cmd_ihex2fw  = IHEX2FW $@
      cmd_ihex2fw  = $(objtree)/$(obj)/ihex2fw $< $@
quiet_cmd_h16tofw  = H16TOFW $@
      cmd_h16tofw  = $(objtree)/$(obj)/ihex2fw -w $< $@

quiet_cmd_fwbin = MK_FW   $@
      cmd_fwbin = FWNAME="$(patsubst firmware/%.gen.S,%,$@)";		     \
		  FWSTR="$(subst /,_,$(subst .,_,$(subst -,_,$(patsubst	     \
				firmware/%.gen.S,%,$@))))";		     \
		  ASM_WORD=$(if $(CONFIG_64BIT),.quad,.long);		     \
		  ASM_ALIGN=$(if $(CONFIG_64BIT),3,2);			     \
		  PROGBITS=$(if $(CONFIG_ARM),%,@)progbits;		     \
		  echo "/* Generated by firmware/Makefile */"		> $@;\
		  echo "    .section .rodata"				>>$@;\
		  echo "    .p2align 4"					>>$@;\
		  echo "_fw_$${FWSTR}_bin:"				>>$@;\
		  echo "    .incbin \"$(2)\""				>>$@;\
		  echo "_fw_end:"					>>$@;\
		  echo "   .section .rodata.str,\"aMS\",$${PROGBITS},1"	>>$@;\
		  echo "    .p2align $${ASM_ALIGN}"			>>$@;\
		  echo "_fw_$${FWSTR}_name:"				>>$@;\
		  echo "    .string \"$$FWNAME\""			>>$@;\
		  echo "    .section .builtin_fw,\"a\",$${PROGBITS}"	>>$@;\
		  echo "    .p2align $${ASM_ALIGN}"			>>$@;\
		  echo "    $${ASM_WORD} _fw_$${FWSTR}_name"		>>$@;\
		  echo "    $${ASM_WORD} _fw_$${FWSTR}_bin"		>>$@;\
		  echo "    $${ASM_WORD} _fw_end - _fw_$${FWSTR}_bin"	>>$@;

# One of these files will change, or come into existence, whenever
# the configuration changes between 32-bit and 64-bit. The .S files
# need to change when that happens.
wordsize_deps := $(wildcard include/config/64bit.h include/config/32bit.h \
		include/config/ppc32.h include/config/ppc64.h \
		include/config/superh32.h include/config/superh64.h \
		include/config/x86_32.h include/config/x86_64.h \
		firmware/Makefile)

$(patsubst %,$(obj)/%.gen.S, $(fw-external-y)): %: $(wordsize_deps)
	$(call cmd,fwbin,$(fwabs)/$(patsubst $(obj)/%.gen.S,%,$@))

# The .o files depend on the binaries directly; the .S files don't.
$(patsubst %,$(obj)/%.gen.o, $(fw-external-y)): $(obj)/%.gen.o: $(fwdir)/%

# .ihex is used just as a simple way to hold binary files in a source tree
# where binaries are frowned upon. They are directly converted with objcopy.
$(obj)/%: $(obj)/%.ihex
	$(call cmd,ihex)

# Don't depend on ihex2fw if we're installing and it already exists.
# Putting it after | in the dependencies doesn't seem sufficient when
# we're installing after a cross-compile, because ihex2fw has dependencies
# on stuff like /usr/lib/gcc/ppc64-redhat-linux/4.3.0/include/stddef.h and
# thus wants to be rebuilt. Which it can't be, if the prebuilt kernel tree
# is exported read-only for someone to run 'make install'.
ifeq ($(INSTALL):$(wildcard $(obj)/ihex2fw),install:$(obj)/ihex2fw)
ihex2fw_dep :=
else
ihex2fw_dep := $(obj)/ihex2fw
endif

# .HEX is also Intel HEX, but where the offset and length in each record
# is actually meaningful, because the firmware has to be loaded in a certain
# order rather than as a single binary blob. Thus, we convert them into our
# more compact binary representation of ihex records (<linux/ihex.h>)
$(obj)/%.fw: $(obj)/%.HEX $(ihex2fw_dep)
	$(call cmd,ihex2fw)

# .H16 is our own modified form of Intel HEX, with 16-bit length for records.
$(obj)/%.fw: $(obj)/%.H16 $(ihex2fw_dep)
	$(call cmd,h16tofw)

obj-y				 += $(patsubst %,%.gen.o, $(fw-external-y))

ifeq ($(KBUILD_SRC),)
# Makefile.build only creates subdirectories for O= builds, but external
# firmware might live outside the kernel source tree
_dummy := $(foreach d,$(addprefix $(obj)/,$(dir $(fw-external-y))), $(shell [ -d $(d) ] || mkdir -p $(d)))
endif

targets := $(patsubst $(obj)/%,%, \
                                $(shell find $(obj) -name \*.gen.S 2>/dev/null))

hostprogs-y := ihex2fw
